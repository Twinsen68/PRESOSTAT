# Configuration autonome (sans dossier common/ requis).
esphome:
  name: ${device_name}
  friendly_name: ${friendly_name}
  on_boot:
    then:
      - script.execute: update_status_led

esp32:
  board: ${board}
  framework:
    type: arduino

logger:

api:

ota:

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "${friendly_name} Fallback"
    password: ${wifi_ap_password}

captive_portal:

web_server:
  port: 80

globals:
  - id: calibration_step
    type: int
    restore_value: false
    initial_value: "0"
  - id: calibration_active
    type: bool
    restore_value: false
    initial_value: "false"
  - id: led_test_mode
    type: bool
    restore_value: true
    initial_value: "false"

script:
  - id: capture_calibration_point
    mode: queued
    then:
      - if:
          condition:
            lambda: |-
              return id(calibration_active);
          then:
            - if:
                condition:
                  lambda: |-
                    return !isnan(id(pressure_voltage).state);
                then:
                  - lambda: |-
                      float voltage = id(pressure_voltage).state;
                      if (id(calibration_step) == 1) {
                        id(cal_number_1_bar).publish_state(voltage);
                      } else if (id(calibration_step) == 2) {
                        id(cal_number_2_bar).publish_state(voltage);
                      } else if (id(calibration_step) == 3) {
                        id(cal_number_3_bar).publish_state(voltage);
                      } else if (id(calibration_step) == 4) {
                        id(cal_number_4_bar).publish_state(voltage);
                      } else if (id(calibration_step) == 5) {
                        id(cal_number_5_bar).publish_state(voltage);
                      } else if (id(calibration_step) == 6) {
                        id(cal_number_6_bar).publish_state(voltage);
                      }
            - lambda: |-
                if (id(calibration_step) >= 6) {
                  id(calibration_step) = 0;
                  id(calibration_active) = false;
                } else {
                  id(calibration_step) += 1;
                }
  - id: update_status_led
    mode: restart
    then:
      - script.execute: render_status_led
  - id: render_status_led
    mode: restart
    then:
      - lambda: |-
          const float two_pi = 6.283185307f;
          const uint32_t now = millis();
          auto clamp01 = [](float value) -> float {
            if (value < 0.0f) {
              return 0.0f;
            }
            if (value > 1.0f) {
              return 1.0f;
            }
            return value;
          };

          float red = 0.0f;
          float green = 0.0f;
          float blue = 0.0f;

          const float pressure = id(pressure_bar).state;
          const bool pressure_valid = !isnan(pressure);
          const float p_min = id(pressure_hold_min_value).state;
          const float p_max = id(pressure_hold_max_value).state;

          if (id(led_test_mode)) {
            red = ${led_test_red};
            green = ${led_test_green};
            blue = ${led_test_blue};
          } else if (id(calibration_active)) {
            const float phase = (now % 2000) / 2000.0f;
            const float breath = 0.5f - 0.5f * cosf(two_pi * phase);
            const float scale = 0.2f + 0.8f * breath;
            red = ${led_calibration_red} * scale;
            green = ${led_calibration_green} * scale;
            blue = ${led_calibration_blue} * scale;
          } else if (!pressure_valid) {
            red = ${led_invalid_red};
            green = ${led_invalid_green};
            blue = ${led_invalid_blue};
          } else if (id(low_pressure_fault).state) {
            const bool on = ((now / 200) % 2) == 0;
            if (on) {
              red = ${led_fault_red};
              green = ${led_fault_green};
              blue = ${led_fault_blue};
            }
          } else if (pressure < p_min || pressure >= p_max) {
            bool on = false;
            if (pressure < p_min) {
              on = ((now / 1000) % 2) == 0;
            } else {
              const uint32_t phase_ms = now % 1000;
              on = (phase_ms < 120) || (phase_ms >= 240 && phase_ms < 360);
            }
            if (on) {
              red = ${led_out_red};
              green = ${led_out_green};
              blue = ${led_out_blue};
            }
          } else {
            float ratio = (pressure - p_min) / (p_max - p_min);
            ratio = clamp01(ratio);
            const float gamma = 2.0f;
            float intensity = ${led_in_green_min}
              + ( ${led_in_green_max} - ${led_in_green_min}) * powf(ratio, gamma);
            if (id(relay_pump).state) {
              const float phase = (now % 2000) / 2000.0f;
              const float pulse = sinf(two_pi * phase);
              const float amplitude = 0.15f * (${led_in_green_max} - ${led_in_green_min});
              intensity += amplitude * pulse;
            }
            green = clamp01(intensity);
          }

          auto call = id(status_led).turn_on();
          call.set_rgb(clamp01(red), clamp01(green), clamp01(blue));
          call.perform();

button:
  - platform: template
    name: "Calibration Demarrer"
    id: calibration_start
    on_press:
      - lambda: |-
          id(calibration_active) = true;
          id(calibration_step) = 1;
          id(led_test_mode) = false;
      - script.execute: update_status_led
  - platform: template
    name: "Calibration Valider Palier"
    id: calibration_confirm
    on_press:
      - if:
          condition:
            lambda: |-
              return id(calibration_active);
          then:
            - script.execute: capture_calibration_point
  - platform: template
    name: "Calibration Annuler"
    id: calibration_cancel
    on_press:
      - lambda: |-
          id(calibration_active) = false;
          id(calibration_step) = 0;
      - script.execute: update_status_led

text_sensor:
  - platform: template
    name: "Calibration Etat"
    id: calibration_status
    update_interval: 1s
    lambda: |-
      if (!id(calibration_active)) {
        return {"Inactive"};
      }
      if (id(calibration_step) == 1) {
        return {"Regler a 1 bar puis appuyer bouton"};
      }
      if (id(calibration_step) == 2) {
        return {"Regler a 2 bar puis appuyer bouton"};
      }
      if (id(calibration_step) == 3) {
        return {"Regler a 3 bar puis appuyer bouton"};
      }
      if (id(calibration_step) == 4) {
        return {"Regler a 4 bar puis appuyer bouton"};
      }
      if (id(calibration_step) == 5) {
        return {"Regler a 5 bar puis appuyer bouton"};
      }
      if (id(calibration_step) == 6) {
        return {"Regler a 6 bar puis appuyer bouton"};
      }
      return {"Termine"};

number:
  - platform: template
    name: "Seuil Pression Min"
    id: hold_min_number
    min_value: 0.0
    max_value: 16.0
    step: 0.1
    optimistic: true
    restore_value: true
    initial_value: ${pressure_hold_min}
    on_value:
      - script.execute: update_status_led
  - platform: template
    name: "Seuil Pression Max"
    id: hold_max_number
    min_value: 0.0
    max_value: 16.0
    step: 0.1
    optimistic: true
    restore_value: true
    initial_value: ${pressure_hold_max}
    on_value:
      - script.execute: update_status_led
  - platform: template
    name: "Calibration 1 bar (V)"
    id: cal_number_1_bar
    min_value: 0.0
    max_value: 5.0
    step: 0.01
    optimistic: true
    restore_value: true
    initial_value: 0.0
  - platform: template
    name: "Calibration 2 bar (V)"
    id: cal_number_2_bar
    min_value: 0.0
    max_value: 5.0
    step: 0.01
    optimistic: true
    restore_value: true
    initial_value: 0.0
  - platform: template
    name: "Calibration 3 bar (V)"
    id: cal_number_3_bar
    min_value: 0.0
    max_value: 5.0
    step: 0.01
    optimistic: true
    restore_value: true
    initial_value: 0.0
  - platform: template
    name: "Calibration 4 bar (V)"
    id: cal_number_4_bar
    min_value: 0.0
    max_value: 5.0
    step: 0.01
    optimistic: true
    restore_value: true
    initial_value: 0.0
  - platform: template
    name: "Calibration 5 bar (V)"
    id: cal_number_5_bar
    min_value: 0.0
    max_value: 5.0
    step: 0.01
    optimistic: true
    restore_value: true
    initial_value: 0.0
  - platform: template
    name: "Calibration 6 bar (V)"
    id: cal_number_6_bar
    min_value: 0.0
    max_value: 5.0
    step: 0.01
    optimistic: true
    restore_value: true
    initial_value: 0.0

i2c:
  sda: ${i2c_sda_pin}
  scl: ${i2c_scl_pin}
  scan: true

font:
  - file: "gfonts://Roboto"
    id: roboto_18
    size: 18
  - file: "gfonts://Roboto"
    id: roboto_24
    size: 24
  - file: "gfonts://Roboto"
    id: roboto_12
    size: 12
  - file: "gfonts://Roboto"
    id: roboto_10
    size: 10
  - file: "gfonts://Roboto"
    id: roboto_9
    size: 9
  - file: "gfonts://Roboto"
    id: roboto_8
    size: 8
  - file: "gfonts://Roboto"
    id: roboto_14
    size: 14

switch:
  - platform: gpio
    id: relay_pump
    name: "Relais Pompe"
    pin:
      number: ${relay_pin}
      inverted: ${relay_inverted}
    restore_mode: RESTORE_DEFAULT_OFF
    on_turn_on:
      - script.execute: update_status_led
    on_turn_off:
      - script.execute: update_status_led
  - platform: template
    id: led_test_switch
    name: "Test LED (Bypass Script)"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    turn_on_action:
      - lambda: |-
          id(led_test_mode) = true;
          id(calibration_active) = false;
          id(calibration_step) = 0;
      - script.execute: update_status_led
    turn_off_action:
      - lambda: |-
          id(led_test_mode) = false;
      - script.execute: update_status_led

binary_sensor:
  - platform: gpio
    id: pump_button
    name: "Bouton Pompe"
    pin:
      number: ${button_pin}
      mode:
        input: true
        pullup: true
      inverted: true
    filters:
      - delayed_on: 50ms
      - delayed_off: 50ms
    on_press:
      - if:
          condition:
            lambda: |-
              return id(calibration_active);
          then:
            - script.execute: capture_calibration_point
          else:
            - switch.toggle: relay_pump

  - platform: template
    id: low_pressure_fault
    name: "Pression Basse Persistante"
    device_class: problem
    lambda: |-
      if (isnan(id(pressure_bar).state)) {
        return false;
      }
      return id(pressure_bar).state < ${pressure_fault_min};
    filters:
      - delayed_on: 5min
    on_press:
      - switch.turn_off: relay_pump
      - script.execute: update_status_led

sensor:
  - platform: homeassistant
    id: hold_min_sensor
    entity_id: ${pressure_hold_min_sensor}
    internal: true
    on_value:
      - script.execute: update_status_led
  - platform: homeassistant
    id: hold_max_sensor
    entity_id: ${pressure_hold_max_sensor}
    internal: true
    on_value:
      - script.execute: update_status_led

  - platform: template
    id: pressure_hold_min_value
    internal: true
    update_interval: 1s
    lambda: |-
      if (!isnan(id(hold_min_sensor).state)) {
        return id(hold_min_sensor).state;
      }
      return id(hold_min_number).state;
  - platform: template
    id: pressure_hold_max_value
    internal: true
    update_interval: 1s
    lambda: |-
      if (!isnan(id(hold_max_sensor).state)) {
        return id(hold_max_sensor).state;
      }
      return id(hold_max_number).state;

  - platform: wifi_signal
    id: wifi_signal_db
    name: "WiFi Signal"
    update_interval: 30s
    unit_of_measurement: "dBm"
    accuracy_decimals: 0
  - platform: wifi_signal
    id: wifi_signal_percent
    name: "WiFi Signal Percent"
    update_interval: 30s
    unit_of_measurement: "%"
    accuracy_decimals: 0
    filters:
      - lambda: |-
          if (isnan(x)) {
            return NAN;
          }
          const float percent = 2.0f * (x + 100.0f);
          if (percent < 0.0f) {
            return 0.0f;
          }
          if (percent > 100.0f) {
            return 100.0f;
          }
          return percent;

  - platform: internal_temperature
    id: esp_temperature
    name: "Temperature ESP"
    update_interval: 30s
    unit_of_measurement: "Â°C"
    accuracy_decimals: 1

  - platform: adc
    id: pressure_voltage
    pin: ${pressure_adc_pin}
    name: "Tension Capteur Pression"
    attenuation: 12db
    update_interval: 1s
    unit_of_measurement: "V"
    accuracy_decimals: 2

  - platform: template
    id: pressure_bar
    name: "Pression"
    unit_of_measurement: "bar"
    accuracy_decimals: 2
    update_interval: 1s
    lambda: |-
      const float v_min = ${pressure_voltage_min};
      const float v_max = ${pressure_voltage_max};
      const float p_min = ${pressure_bar_min};
      const float p_max = ${pressure_bar_max};
      if (isnan(id(pressure_voltage).state)) {
        return NAN;
      }
      float voltage = id(pressure_voltage).state;
      const float v1 = id(cal_number_1_bar).state;
      const float v2 = id(cal_number_2_bar).state;
      const float v3 = id(cal_number_3_bar).state;
      const float v4 = id(cal_number_4_bar).state;
      const float v5 = id(cal_number_5_bar).state;
      const float v6 = id(cal_number_6_bar).state;
      const bool calibrated = (v1 > 0.0f && v2 > v1 && v3 > v2 && v4 > v3 && v5 > v4 && v6 > v5);

      auto clamp_pressure = [&](float pressure) -> float {
        if (pressure < p_min) {
          return p_min;
        }
        if (pressure > p_max) {
          return p_max;
        }
        return pressure;
      };

      if (!calibrated) {
        float pressure = (voltage - v_min) * (p_max - p_min) / (v_max - v_min) + p_min;
        return clamp_pressure(pressure);
      }

      auto interp = [&](float v_low, float v_high, float p_low, float p_high) -> float {
        if (v_high <= v_low) {
          return p_low;
        }
        return (voltage - v_low) * (p_high - p_low) / (v_high - v_low) + p_low;
      };

      if (voltage <= v1) {
        return clamp_pressure(interp(v_min, v1, p_min, 1.0f));
      }
      if (voltage <= v2) {
        return clamp_pressure(interp(v1, v2, 1.0f, 2.0f));
      }
      if (voltage <= v3) {
        return clamp_pressure(interp(v2, v3, 2.0f, 3.0f));
      }
      if (voltage <= v4) {
        return clamp_pressure(interp(v3, v4, 3.0f, 4.0f));
      }
      if (voltage <= v5) {
        return clamp_pressure(interp(v4, v5, 4.0f, 5.0f));
      }
      if (voltage <= v6) {
        return clamp_pressure(interp(v5, v6, 5.0f, 6.0f));
      }
      return clamp_pressure(interp(v6, v_max, 6.0f, p_max));
    on_value:
      then:
        - script.execute: update_status_led
        - if:
            condition:
              lambda: |-
                return !isnan(x) && x < id(pressure_hold_min_value).state;
            then:
              - switch.turn_on: relay_pump
        - if:
            condition:
              lambda: |-
                return !isnan(x) && x >= id(pressure_hold_max_value).state;
            then:
              - switch.turn_off: relay_pump

light:
  - platform: esp32_rmt_led_strip
    id: status_led
    name: "LED Statut"
    pin: ${led_pin}
    num_leds: 1
    rgb_order: ${led_rgb_order}
    chipset: ${led_chipset}
    restore_mode: ALWAYS_OFF

interval:
  - interval: 200ms
    then:
      - script.execute: render_status_led

display:
  - platform: ssd1306_i2c
    model: "SSD1306 128x64"
    address: 0x3C
    lambda: |-
      if (id(calibration_active)) {
        it.printf(0, 0, id(roboto_18), "Calibration");
        it.printf(0, 17, id(roboto_14), "Palier: %d bar", id(calibration_step));
        it.printf(0, 34, id(roboto_9), "Tension: %.2f V",
          isnan(id(pressure_voltage).state) ? 0.0f : id(pressure_voltage).state);
        it.printf(0, 50, id(roboto_9), "Appuyer bouton");
        return;
      }
      it.printf(0, 0, id(roboto_24), "%.2f bar",
        isnan(id(pressure_bar).state) ? 0.0f : id(pressure_bar).state);
      it.printf(0, 25, id(roboto_12), "Pompe: %s",
        id(relay_pump).state ? "ON" : "OFF");
      it.printf(0, 38, id(roboto_12), "Seuils %.1f-%.1f bar",
        isnan(id(pressure_hold_min_value).state) ? 0.0f : id(pressure_hold_min_value).state,
        isnan(id(pressure_hold_max_value).state) ? 0.0f : id(pressure_hold_max_value).state);
      it.printf(0, 54, id(roboto_10), "Defaut:%s - WiFi %.0f%% %.1fC",
        id(low_pressure_fault).state ? "OUI" : "NON",
        isnan(id(wifi_signal_percent).state) ? 0.0f : id(wifi_signal_percent).state,
        isnan(id(esp_temperature).state) ? 0.0f : id(esp_temperature).state);
